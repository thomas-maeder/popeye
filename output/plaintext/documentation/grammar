terminal eol {\n}
terminal emptyLine {\n}
terminal lineText {[^\n]}
terminal space { }
terminal hyphen {-}
terminal nonspace {[^ ]}
terminal period {[.]}

terminal time [literal time]
terminal equals {=}
terminal durationSeconds {[[:digit:]]{1,2}[.][[:digit:]]{3} s}
terminal durationMinutes {[[:digit:]]{1,2}:[[:digit:]]{2}[.][[:digit:]]{3} m:s}
terminal durationHours {[[:digit:]]+:[[:digit:]]{2}:[[:digit:]]{2}[.][[:digit:]]{3} h:m:s}
nonterminal duration { durationSeconds | durationMinutes | durationHours }
nonterminal solvingTime { time space equals space duration }

# we can't distinguish remarks (in the input) and error messages produced during validation
namespace eval remarkOrValidationError {
    nonterminal remark { lineText+ }
    nonterminal remarkLine { remark eol }

    nonterminal block { remarkLine* }
}

namespace eval meta {
    nonterminal leadingBlanks { space* }

    nonterminal authorOriginAwardTitle { lineText+ }
    nonterminal authorOriginAwardTitleLine { leadingBlanks authorOriginAwardTitle eol }

    nonterminal block { emptyLine authorOriginAwardTitleLine* }
}

namespace eval board {
    terminal cornerSign {[+]}
    terminal verticalBorderSign {[|]}
    terminal horizontalBorderSign "-"
    terminal columnName {[a-h]}
    terminal rowNo {[1-8]}
    terminal gridVertical {[|]}
    terminal white " "
    terminal black "-"
    terminal neutral "="
    terminal walkChar {[[:upper:][:digit:]]}
    terminal hunterPartsSeparator "/"

    nonterminal columnSpec { horizontalBorderSign horizontalBorderSign columnName horizontalBorderSign }
    nonterminal columns { cornerSign horizontalBorderSign columnSpec+ horizontalBorderSign horizontalBorderSign cornerSign eol }

    nonterminal gridHorizontal { space hyphen hyphen hyphen }
    nonterminal squareEmptyChar1 { space | gridVertical }
    nonterminal squareEmpty { squareEmptyChar1 space period }
    nonterminal hole { squareEmptyChar1 space space }
    nonterminal color { white | black | neutral }
    nonterminal walk1Char { squareEmptyChar1 color walkChar }
    nonterminal squareOccupiedChar1 { color | gridVertical }
    nonterminal walk2Chars { squareOccupiedChar1 walkChar walkChar }
    nonterminal regularSeparator { space }
    nonterminal separator { regularSeparator | hunterPartsSeparator }
    nonterminal pieceOrNoPiece { squareEmpty | hole | walk1Char | walk2Chars }
    nonterminal pieceCell { pieceOrNoPiece separator }
    nonterminal piecesLine { rowNo space pieceCell+ space space rowNo eol }

    nonterminal hunter2ndPart { hole | walk1Char | walk2Chars }
    nonterminal spaceLineCell { hunter2ndPart regularSeparator | gridHorizontal }
    nonterminal spaceLine { verticalBorderSign space spaceLineCell+ space space verticalBorderSign eol }

    nonterminal linePair { spaceLine piecesLine }

    nonterminal block {
        emptyLine
        columns
        linePair+
        spaceLine
        columns
    }
}

namespace eval gridboard {
    terminal cell {  [ [:digit:]][[:digit:]]}

    nonterminal cellsline { board::rowNo cell+ space space space board::rowNo eol }
    nonterminal linePair { board::spaceLine cellsline }
    nonterminal block {
        emptyLine
        board::columns
        linePair+
        board::spaceLine
        board::columns
    }
}

namespace eval goal {
    terminal mate "#"
    terminal stalemate "="
    terminal dia "dia"
    terminal aToB "a=>b"
    terminal targetSquare {z[a-h][1-8]}
    terminal targetSquareImplicit "z"
    terminal circuit "ct"
    terminal exchange "<>"
    terminal exchangeByRebirth "<>r"
    terminal check {[+]}
    terminal doubleStalemate "=="
    terminal castling "00"
    terminal pieceWin "%"
    terminal anyMove "~"
    terminal bothMate "##"
    terminal counterMate "##!"
    terminal autoMate "!="
    terminal enPassant "ep"
    terminal capture "x"
    terminal circuitByRebirth "ctr"
    terminal chess81 "c81"
    terminal immobile "#="
    terminal noMate "!#"
    terminal kiss {k[a-h][1-8]}
}

namespace eval stipulation {
    terminal exactPrefix {exact-}
    terminal introPrefix {[[:digit:]]+->}
    terminal parryPrefix {ph?}
    terminal seriesPrefix {ser-}
    terminal helpPrefix "h"
    terminal paren_open {[(]}
	terminal paren_close {[)]}
    terminal reciPrefix {reci-h}
    terminal selfPrefix "s"
    terminal reflexPrefix {(?:semi-)?r}
    terminal length {[[:digit:]]+(?:[.]5)?}
    terminal sideWhite [literal white]
    terminal sideBlack [literal black]
    terminal maxthreatSuffix {/[[:digit:]]*}
    terminal maxflightSuffix {/[[:digit:]]+}
    terminal nontrivialSuffix {;[[:digit:]]+,[[:digit:]]+}

    nonterminal side { sideWhite | sideBlack }

    nonterminal goal {
	goal::mate
	| goal::stalemate
	| goal::dia
	| goal::aToB
	| goal::targetSquare
	| goal::circuit
	| goal::exchange
	| goal::check
	| goal::doubleStalemate
	| goal::castling
	| goal::pieceWin
	| goal::anyMove
	| goal::bothMate
	| goal::counterMate
	| goal::autoMate
	| goal::enPassant
	| goal::capture
	| goal::circuitByRebirth
	| goal::exchangeByRebirth
	| goal::chess81
	| goal::immobile
	| goal::noMate
	| goal::kiss
    }

    nonterminal helpselfPrefix { helpPrefix selfPrefix }
    nonterminal helpreflexPrefix { helpPrefix reflexPrefix }
    nonterminal genericSeriesPrefix { introPrefix? parryPrefix? seriesPrefix }
    nonterminal recigoal { paren_open goal paren_close }
    nonterminal recihelpPrefix { reciPrefix recigoal? }
    nonterminal alternatePrefix { helpPrefix | recihelpPrefix | selfPrefix | helpselfPrefix | reflexPrefix | helpreflexPrefix }
    nonterminal playPrefix { exactPrefix? genericSeriesPrefix? alternatePrefix? }
    nonterminal traditional { playPrefix goal length }

    # structured stipulations are recursive, which can't be represented by
    # regular expressions
    nonterminal structured { side space nonspace+ }

    nonterminal maxSuffix { maxthreatSuffix maxflightSuffix? }
    nonterminal suffix { maxSuffix? nontrivialSuffix? }

    nonterminal combined { traditional | structured }

    nonterminal block { combined suffix }
}

namespace eval pieceControl {
    terminal piecesOfColor {[[:digit:]]+}
    terminal separator { [+] }
    terminal totalInvisiblePseudoWalk "TI"
    terminal neutral "n"

    nonterminal piecesNeutral { separator piecesOfColor neutral }
    nonterminal piecesTotalInvisible { separator piecesOfColor space totalInvisiblePseudoWalk }
    nonterminal block { piecesOfColor separator piecesOfColor piecesNeutral? piecesTotalInvisible? }
}

namespace eval caption {
    nonterminal block { space* stipulation::block space* pieceControl::block eol }
}

namespace eval boardA {
    terminal tomoveIndicator "->"
    terminal arrow "=>"

    # the caption of board A doesn't indicate the stipulation
    nonterminal captionLine { space* pieceControl::block eol }
    nonterminal tomove { stipulation::paren_open stipulation::side space tomoveIndicator stipulation::paren_close }
    nonterminal tomoveLine { space* arrow space tomove eol }
    nonterminal block {
        board::block
        captionLine
        emptyLine
        tomoveLine
        emptyLine
    }
}

namespace eval conditions {
    nonterminal line { space* lineText+ eol }
    nonterminal block { line* }
}

namespace eval duplex {
    terminal duplex [literal duplex]
    terminal halfduplex [literal halfduplex]

    nonterminal duplexOrHalf { duplex | halfduplex }
    nonterminal line { space* duplexOrHalf eol }
    nonterminal block { line? }
}

namespace eval solution {
    terminal naturalNumber {[1-9][0-9]*}
    terminal paren_open {[(]}
	terminal paren_close {[)]}
    terminal bracket_open {\[}
    terminal bracket_close {\]}
    terminal ellipsis {[.][.][.]}
    terminal comma ","
    terminal period {[.]}
    terminal square {[a-h][1-8]}
    terminal capture {[*]}
    terminal captureOrNot {[-*]}
    terminal castlingQ "0-0-0"
    terminal castlingK "0-0"
    terminal enPassant { ep[.]}
    terminal vulcanization "->v"
    terminal promotionIndicator "="
    terminal pieceAdditionIndicator {[+]}
    terminal pieceRemovalIndicator "-"
    terminal pieceMovementIndicator "->"
    terminal pieceExchangeIndicator "<->"
    terminal bglNumber {[[:digit:]]+(?:[.][[:digit:]]{1,2})?}
    terminal bglNone "-"
    terminal bglDividedBy "/"
    terminal checkIndicator { [+]}
    terminal moveNumber {[1-9][0-9]*}
    terminal nrPositions {[[:digit:]]+}
    terminal nrMoves {[[:digit:]]+[+][[:digit:]]+}
    terminal legalityUndecidable [literal legalityUndecidable]
    terminal refutationUndecidable [literal refutationUndecidable]
    terminal imitatorSign "I"
    terminal castlingPartnerSeparator "/"
    terminal roleExchange [literal roleExchange]
    terminal potentialPositionsIn [literal potentialPositionsIn]
    terminal totalInvisibleMovePrefix "TI~"
    terminal totalInvisibleMoveSuffix "-~"
    terminal forcedReflexMoveIndicator {[?]![?]}
    terminal measurement { *[[:alpha:]_]+: *[[:digit:]]+}

    namespace eval pieceAttributeShortcut {
	terminal white [literal pieceAttributeShortcut::white]
	terminal black [literal pieceAttributeShortcut::black]
	terminal neutral [literal pieceAttributeShortcut::neutral]
	terminal royal [literal pieceAttributeShortcut::royal]
	terminal kamikaze [literal pieceAttributeShortcut::kamikaze]
	terminal paralyzing [literal pieceAttributeShortcut::paralyzing]
	terminal chameleon [literal pieceAttributeShortcut::chameleon]
	terminal jigger [literal pieceAttributeShortcut::jigger]
	terminal volage [literal pieceAttributeShortcut::volage]
	terminal functionary [literal pieceAttributeShortcut::functionary]
	terminal halfneutral [literal pieceAttributeShortcut::halfneutral]
	terminal hurdleColourChanging [literal pieceAttributeShortcut::hurdleColourChanging]
	terminal protean [literal pieceAttributeShortcut::protean]
	terminal magic [literal pieceAttributeShortcut::magic]
	terminal uncapturable [literal pieceAttributeShortcut::uncapturable]
	terminal patrol [literal pieceAttributeShortcut::patrol]
	terminal frischauf [literal pieceAttributeShortcut::frischauf]

	nonterminal colour { white | black | neutral }

	nonterminal nonColour {
	    royal?
	    kamikaze?
	    paralyzing?
	    chameleon?
	    jigger?
	    volage?
	    functionary?
	    halfneutral?
	    hurdleColourChanging?
	    protean?
	    magic?
	    uncapturable?
	    patrol?
	    frischauf?
	}
    }

nonterminal undec { legalityUndecidable | refutationUndecidable }

nonterminal goal {
    goal::mate
    | goal::stalemate
    | goal::dia
    | goal::aToB
    | goal::targetSquareImplicit
    | goal::circuit
    | goal::exchange
    | goal::check
    | goal::doubleStalemate
    | goal::castling
    | goal::pieceWin
    | goal::anyMove
    | goal::bothMate
    | goal::counterMate
    | goal::autoMate
    | goal::enPassant
    | goal::capture
    | goal::circuitByRebirth
    | goal::exchangeByRebirth
    | goal::chess81
    | goal::immobile
    | goal::noMate
    | goal::kiss
}
nonterminal goalIndicator { space goal }

nonterminal ordinalNumber { naturalNumber period }

nonterminal hunterSuffix { board::hunterPartsSeparator board::walkChar{1,2} }
nonterminal walk { board::walkChar{1,2} hunterSuffix? }
nonterminal walkPawnImplicit { board::walkChar{0,2} hunterSuffix? }

nonterminal movementTo { captureOrNot square }
nonterminal movementFromTo { pieceAttributeShortcut::colour? pieceAttributeShortcut::nonColour walkPawnImplicit square movementTo }
nonterminal castlingPartnerMovement { castlingPartnerSeparator pieceAttributeShortcut::colour pieceAttributeShortcut::nonColour walkPawnImplicit square movementTo }
nonterminal movementBasic { movementFromTo castlingPartnerMovement? | castlingQ | castlingK }
nonterminal movementComposite { movementBasic movementTo* }
nonterminal messignyExchange { walk square pieceExchangeIndicator walk square }
nonterminal promotion { promotionIndicator pieceAttributeShortcut::colour? pieceAttributeShortcut::nonColour walk? }
nonterminal pieceChangement { square promotion }
nonterminal pieceSpec { pieceAttributeShortcut::colour? pieceAttributeShortcut::nonColour walk square }
nonterminal pieceMovement {
    pieceSpec
    pieceMovementIndicator
    pieceAttributeShortcut::colour?
    pieceAttributeShortcut::nonColour
    walk?
    square
    promotion*
    vulcanization?
}
nonterminal pieceAddition { pieceAdditionIndicator pieceSpec promotion* vulcanization? }
nonterminal pieceRemoval { pieceRemovalIndicator pieceSpec }
nonterminal pieceExchange { pieceSpec pieceExchangeIndicator pieceSpec }
nonterminal pieceEffect { pieceMovement | pieceAddition | pieceRemoval | pieceChangement | pieceExchange }
nonterminal otherPieceEffect { bracket_open pieceEffect bracket_close }
nonterminal nextImitatorPosition { comma square }
nonterminal imitatorMovement { bracket_open imitatorSign square nextImitatorPosition* bracket_close }
nonterminal bglFirstPart { bglNone | bglNumber }
nonterminal bglSecondPart { bglDividedBy bglNumber }
nonterminal bglBalance { space paren_open bglFirstPart bglSecondPart? paren_close }
nonterminal totalInvisibleMove { totalInvisibleMovePrefix totalInvisibleMoveSuffix }
nonterminal totalInvisibleCapture { totalInvisibleMovePrefix capture square }
nonterminal movingPieceMovement { movementComposite | totalInvisibleMove | totalInvisibleCapture | messignyExchange }
nonterminal movementAddons { enPassant? imitatorMovement? promotion* otherPieceEffect* }
nonterminal movingPieceMovementWithEffects { movingPieceMovement movementAddons }
nonterminal seriesCaptureStep { movementTo movementAddons }
nonterminal regularMove { otherPieceEffect* movingPieceMovementWithEffects seriesCaptureStep* bglBalance? checkIndicator? }
nonterminal move { space roleExchange | space ellipsis | regularMove }

nonterminal moveNumberLineNonIntelligent { space* moveNumber space space paren_open move space+ solvingTime? paren_close eol }
nonterminal solvingTimeIndication { space+ paren_open solvingTime paren_close}
nonterminal moveNumberLineIntelligent { nrPositions space potentialPositionsIn space nrMoves solvingTimeIndication? eol }

nonterminal forcedReflexMove { space+ ordinalNumber move goalIndicator space forcedReflexMoveIndicator eol }

namespace eval tree {
    terminal zugzwang [literal zugzwang]
    terminal threat [literal threat]
    terminal refutationIndicator "!"
    terminal refutesIndicator [literal refutes]
    terminal keySuccess {[?!]}
    terminal but [literal but]

    nonterminal attack { ordinalNumber move }
    nonterminal defense { naturalNumber ellipsis move }

    # in condition "lost pieces", lost pieces of the attacker may be removed
    nonterminal zugzwangOrThreat { space zugzwang | space threat otherPieceEffect? }

    nonterminal keySuccessSuffix { space undec | goalIndicator? space keySuccess zugzwangOrThreat? }
    nonterminal keyLine { space space space attack keySuccessSuffix eol }

    nonterminal attackSuffix { space undec | goalIndicator | zugzwangOrThreat }
    nonterminal attackLine { space+ attack attackSuffix? eol }
    nonterminal defenseSuffix { space undec | goalIndicator }
    nonterminal defenseLine { space+ defense defenseSuffix? eol }

    # TODO should Popeye write an empty line before the check indicator?
    nonterminal checkOrZugzwangOrThreat { checkIndicator | emptyLine zugzwangOrThreat }
    nonterminal checkOrZugzwangOrThreatLine { checkOrZugzwangOrThreat eol }

    nonterminal refutesLine { space+ refutesIndicator eol }
    nonterminal postKeyPlayLine { defenseLine refutesLine? | attackLine }
    nonterminal postKeyPlay { checkOrZugzwangOrThreatLine? postKeyPlayLine* }

    nonterminal refutation {
	space+ defense goalIndicator? space refutationIndicator eol
	forcedReflexMove?
    }

    nonterminal refutationBlock {
	space+ but eol
	refutation+
    }

    nonterminal playAfterKeyLine { defenseLine | attackLine }
    nonterminal playAfterKeyBlock { playAfterKeyLine+ }

    nonterminal fullPhaseBlock {
	keyLine
	playAfterKeyBlock?
	refutationBlock?
	emptyLine
    }

    nonterminal setplayBlock { emptyLine playAfterKeyBlock }

    nonterminal regularPlaySegment { moveNumberLineNonIntelligent | fullPhaseBlock }
    nonterminal regularplayBlock { emptyLine regularPlaySegment+ }

    nonterminal block { postKeyPlay | setplayBlock? regularplayBlock* }
}

namespace eval line {
    nonterminal moveSuffix { space undec eol | goalIndicator }
    nonterminal moveNumberLine { moveNumberLineNonIntelligent | moveNumberLineIntelligent }
    nonterminal numberedHalfMove { space+ ordinalNumber move }
    nonterminal unnumberedHalfMove { space+ move }

    namespace eval helpplay {
	terminal one "1"

	nonterminal movePair { numberedHalfMove unnumberedHalfMove }
	# this is too generic: it allows lines without any move
	# requiring >=1 move would be complicated, though
	nonterminal movesSequence { movePair* numberedHalfMove? moveSuffix? eol}

	# set play of h#n.5
	namespace eval twoEllipsis {
	    nonterminal firstMovePairSkipped { one ellipsis space+ ellipsis }
	    nonterminal movesLine { space+ firstMovePairSkipped movesSequence }
	    nonterminal line { movesLine | moveNumberLine }
	    nonterminal block { line+ }
	}

# set play of h#n or regular play of h#n.5
namespace eval oneEllipsis {
    nonterminal firstMoveSkipped { one ellipsis move }
    nonterminal movesLine { space+ firstMoveSkipped movesSequence }
    nonterminal line { movesLine | moveNumberLine }
    nonterminal block { line+ }
}

# regular play of h#n
namespace eval noEllipsis {
    nonterminal line { movesSequence | moveNumberLine }
    nonterminal block { line+ }
}

nonterminal block {
    twoEllipsis::block? emptyLine? oneEllipsis::block
    | oneEllipsis::block? emptyLine? noEllipsis::block?
}
}

namespace eval seriesplay {
    nonterminal fullMove { numberedHalfMove unnumberedHalfMove* }
    nonterminal movesLine { fullMove+ moveSuffix? eol }
    nonterminal line { movesLine | moveNumberLine }
    nonterminal block { line* }
}

nonterminal block { helpplay::block | seriesplay::block }
}

nonterminal measurementLine { measurement eol }
nonterminal measurementsBlock { measurementLine+ }

namespace eval untwinned {
    terminal toofairy [literal toofairy]
    terminal nonsensecombination [literal nonsensecombination]
    terminal conditionSideUndecidable [literal conditionSideUndecidable]
    terminal problemignored [literal problemignored]
    terminal illegalSelfCheck [literal illegalSelfCheck]
    terminal kingmissing [literal kingmissing]
    terminal threatNotApplicable [literal threatNotApplicable]
    terminal intelligentAndFairy [literal intelligentAndFairy]

    nonterminal error {
	toofairy
	| nonsensecombination
	| conditionSideUndecidable
    }
    nonterminal problemignoredMsg {
	error eol
	problemignored eol
    }
    nonterminal simplexPart { illegalSelfCheck eol | emptyLine forcedReflexMove+ | tree::block | emptyLine line::block }
    nonterminal simplex { simplexPart+ measurementsBlock? }
    nonterminal solvingResult { problemignoredMsg | simplex{1,2} }

    nonterminal warning {
	kingmissing
	| threatNotApplicable
	| intelligentAndFairy
    }
    nonterminal warningLine { warning eol }

    nonterminal block { warningLine* solvingResult remarkOrValidationError::block? }
}

namespace eval twinning {
    terminal continued {[+]}
    terminal label {[[:lower:]][[:digit:]]*[)]}

nonterminal additionalLine { space space space+ lineText+ eol }
nonterminal block {
    emptyLine
    continued? label space lineText* eol
    additionalLine*
}
}

namespace eval twinned {
    nonterminal twinblock { twinning::block untwinned::block }
    nonterminal block { twinblock+ }
}

nonterminal block { untwinned::block | twinned::block }
}

namespace eval footer {
    terminal endOfSolution [literal endOfSolution]
    terminal partialSolution [literal partialSolution]
    nonterminal solvingTimeIndication { space solvingTime }

    nonterminal solutionEnd { endOfSolution | partialSolution }
    nonterminal block { eol solutionEnd solvingTimeIndication? eol emptyLine emptyLine }
}

namespace eval zeroposition {
    terminal zeroposition [literal zeroposition]

    nonterminal block { emptyLine zeroposition eol emptyLine }
}

namespace eval inputerror {
    terminal inputError [literal inputError]
    terminal offendingItem [literal offendingItem]

    nonterminal block {
        inputError lineText+ eol
        offendingItem lineText+ eol
    }
}

namespace eval problem {
    terminal popeye [literal popeye]

    nonterminal popeyeLine { popeye lineText+ eol }

    nonterminal noNonboardBlock {
        meta::block
        boardA::block?
        board::block
        caption::block
        conditions::block
        duplex::block
        gridboard::block?
        zeroposition::block?
    }

    nonterminal block {
	popeyeLine?
	inputerror::block*
	remarkOrValidationError::block
	noNonboardBlock?
	solution::block?
	footer::block
    }
}
